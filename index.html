<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="http://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/topojson.v1.min.js"></script>
  <style>

.circle{
  fill: rgba(244,164,96, 0.6);
  stroke: gray;
  stroke-width: 0.7;
}
.land {
  fill: rgba(205,183,181, 0.3);
}

#cells.voronoi path.cell {
  stroke: brown;
}

.country_borders {
  fill: none;  
  stroke: white;
}

.voronoi {
  fill: none;
  stroke: gray; 
  stroke-opacity: 0.1;
  pointer-events: all;
}

path.arc {
  pointer-events: none;
  fill: none;
  stroke: #000;
  display: none;
}
body {
    background: none;
    text-align: center;
    font-family: 'Roboto', sans-serif;
}
.airport-arc {
  fill: black;
}
.airport:hover .airport-arc {
  stroke: rgba(247, 148, 32, 0.9);
  fill: none;
  stroke-width: 1.5px;
}

.airport-cell {
  fill: none;
  stroke: #000;
  stroke-opacity: 0.1;
  pointer-events: all;
}

.airport:hover .airport-link{
  stroke: #f00;
}

/*code from: https://codemyviews.com/blog/inner-shadows-in-css-images-text-and-beyond*/
#title {
  font-size: 70px;
  font-weight: bold;
  background-color: #8B7765;
  color: transparent;
  text-shadow: 0px 2px 3px rgba(255,255,255,0.4);
  -webkit-background-clip: text;
     -moz-background-clip: text;
          background-clip: text;
}
#subtitle {
  color: #8B7765;
  background: rgba(205,183,181, 0.1);
}

</style>
</head>
<body>  
<!-- Google fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<div id="container">
      <div id="title">Refugee Journey</div>
      <div id="subtitle">Where did they come from?</div>

      
</div>

<script type="text/javascript">
  //  stroke: #f00;
//rgba(13, 46, 80, 0.7)
//land #ddd
//title #565656
  var margin = 75,
    width = 1600,
    height = 600;

var svg = d3.select("body")
          .append("svg")
          .attr("width", width + margin)
          .attr("height", height + margin)
          .append('g')
          .attr('class', 'map');


var projection = d3.geoMercator()
                   .scale(195)
                   .translate([width / 2, height / 1.5]);

var path = d3.geoPath()
             .projection(projection)
             .pointRadius(2.5);

var voronoi = d3.voronoi()
    .extent([[-1, -1], [width + 1, height + 1]]);
/*
var voronoilocal = d3.voronoi()
                      .x(function(d) { return d[0]; })
                      .y(function(d) { return d[1] })
                      .extent([[-1, -1], [width + 1, height + 1]]);
*/

var linksByOrigin = {},
      countCountry = {}, //Total de ocorrencias de cada cidade
      locationCountry = {}, //posicao em px de cada país
      //positions = [], //posicao em px de cada long e lat
      countryF = [];

var opacityScale = d3.scaleLinear()
      .range([ 1,0.9,0.4,0.1,0.1])
      .domain([0,3,  4,  6,  10])
      .clamp(true);


var colorScale = d3.scaleLinear()
      .range(['#fff7b9','#fff196','#ffea72','#ffe348','#fddc18'])
      .domain([0,1,2,4,6])
      .clamp(true);

d3.queue()
    .defer(d3.json, "geo.json")
    .defer(d3.csv, "unhcr_2016.csv", altData)
    .defer(d3.csv, "country.csv", formatCountry)
    .await(ready);

function ready(error, worldmap, countries, countryGeo) {
  if (error) throw error;

///////////Cria mapa////////////////////////////////////////////////////////
  svg.append("path")
      .datum(topojson.feature(worldmap, worldmap.objects.land))
      .attr("class", "land")
      .attr("d", path);

  svg.append("path")
      .datum(topojson.mesh(worldmap, worldmap.objects.countries, function(a, b) { return a !== b; }))
      .attr("class", "country_borders")
      .attr("d", path);


//////////////Agrupa dados////////////////////////////////////////////////////
  var nested = d3.nest()
                 .key(function(d) {
                  return d['Destination'];
                  })
                 .key(function(d) {
                    return d['Origin'];
                 })                 
                 .rollup(agg_year)
                 .entries(countries);


  
 
  ////////////////Formatar os dados//////////////////////////
/*
  countries.forEach(function(d) {
    var origin = d.Origin,
        destination = d.Destination;
    locationCountry[origin] = [+d.long_origin, +d.lat_origin];
    locationCountry[destination] = [+d.long_dest, +d.lat_dest];
    countCountry[origin] = (countCountry[origin] || 0) + 1;
    countCountry[destination] = (countCountry[destination] || 0) + 1;    
  });
*/
  var positions = [];
  var countryid = d3.map(countryGeo, function(d) { return d.country});
  var linkedCoords = [];
  var ttPop = 0;
  nested.forEach(function(k){ 
    linkedCoords = []
    k.arcs = {type: "MultiLineString", coordinates: []};
    var target = countryid.get(k.key);
    k[0] = +target[0];
    k[1] = +target[1];
    positions.push(projection([+target[0],+target[1]]));
    ttPop = 0;
    k.values.forEach(function(v) {
      var source = countryid.get(v.value.origin)
      if ((isLatitude(source[1])) && (isLongitude(source[0]))){
        if ((isLatitude(target[1])) && (isLongitude(target[0]))){                  
          linkedCoords.push([source, target]);
          linkedCoords.push([target, source]);
          ttPop += +v.value.total_population;
          
    }//a.values.forEach(function(b) {
    
      };//if ((isLatitude(source[1])) && (isLongitude(source[0]))){      
    });
    linkedCoords.forEach(function(link){
      k.arcs.coordinates.push(link)
    });
    //k.total_population = ttPop.toLocaleString();
    k.total_population = ttPop;
    delete k.values;
    countryF.push(k);
  });

  delete countryF.values;

  var population_max = d3.max(countryF, function(d) {
                return +d.total_population;
            });

  var radius = d3.scaleSqrt()
                 .domain([0, population_max])
                 .range([0, 15]);

////////////////////////////// Desenha Circulos ///////////////////////////////
/*
  svg.append('g')
    .attr("class", "circle")
    .selectAll('circle')
    .data(nested)
    .enter()
    .append('circle')
    .attr('cx', function(d) {return d.value['x'];})
    .attr('cy', function(d) {return d.value['y'];})
    .attr('r', function (d){ return radius(d.value['population']); });
*/
  
 ////////////////////////////// Prepara dados e ///////////////////////////////
 ////////////////////////////// Cria vinculos entre eles//////////////////////
  
 // let unique_positions = [...new Set(positions)]; 
 // positions = positions.filter(Boolean);

  //countries = countries.filter(Boolean);
  countryF = countryF.filter(function(d) { return d.arcs.coordinates.length; });

/* 
  svg.append("path")
      .datum({type: "MultiPoint", coordinates: countryF})
      .attr("class", "airport-dots")
      .attr("d", path);

*/
  svg.append('g')
    .attr("class", "circle")
    .selectAll('circle')
    .data(countryF)
    .enter()
    .append('circle')
    .attr('cx', function(d) {
              var x = projection([d[0],d[1]])
      return x[0];})
    .attr('cy', function(d) {
      var x = projection([d[0],d[1]]) 
      return x[1];})
    .attr('r', function (d){ return radius(d.total_population); });

  // Calcula o voronoi para as posicoes
 // var polygons = voronoilocal.polygons(positions);
  var polygons = voronoi.polygons(countryF.map(projection));

  var airport = svg.selectAll(".airport")
                   .data(countryF)
                   .enter()
                   .append("g")
                   .attr("class", "airport");
  
  airport.append("title")
      .text(function(d) { return d.key + "\n" + d.arcs.coordinates.length + " Países de origem" + "\n" + "Refugees: " + d.total_population ; });

  airport.append("path")
      .attr("class", "airport-arc")
      .attr("d", function(d) { return path(d.arcs); })
      .style("fill", function(d) { return colorScale(d.total_population)*0.1; });

  airport.append("path")
      .data(polygons)
      .attr("class", "voronoi")
      .attr("d", function(d) { return d ? "M" + d.join("L") + "Z" : null; });
     

 ///////////////////////////////////////////////////////////////////////////

}//function ready(error, worldmap, countries) {


function altData(d) {
    d.Year        = +d.Year;
    d.Total_Population = +d.Total_Population
    d.arcs = {type: "MultiLineString", coordinates: []};
    return d;   
}//altData

function formatCountry(d) {
    d[0] = +d.longitude;
    d[1] = +d.latitude;

    d.arcs = {type: "MultiLineString", coordinates: []};
    return d;   
}//formatCountry

//code from: https://stackoverflow.com/questions/39842004/why-use-regular-expressions-to-validate-latitude-and-longitude-in-javascript
function isLatitude(lat) {
  return isFinite(lat) && Math.abs(lat) <= 90;
}

function isLongitude(lng) {
  return isFinite(lng) && Math.abs(lng) <= 180;
}

function agg_year(leaves) {
    var total = d3.sum(leaves, function(d) {
          return d['Total_Population'];
      });
    
    var origin = leaves[0]['Origin'];
    var destination = leaves[0]['Destination'];

    return {
      'destination' : destination,      
      'origin' : origin,
      'total_population' : total,
      'arcs': {type: "MultiLineString", coordinates: []}
    };
  }//agg_year(l

</script>
<div id="week"></div>
      <div id="legend"></div>
      <div id="stopstart">loading data...</div>

      <div id="explanation">
        <p>UNHCR's populations of concern

<p>Refugees include individuals recognised under the 1951 Convention relating to the Status of Refugees; its 1967 Protocol; the 1969 OAU Convention Governing the Specific Aspects of Refugee Problems in Africa; those recognised in accordance with the UNHCR Statute; individuals granted complementary forms of protection; or those enjoying temporary protection. Since 2007, the refugee population also includes people in a refugee-like situation.</p>

<p>Asylum-seekers are individuals who have sought international protection and whose claims for refugee status have not yet been determined, irrespective of when they may have been lodged.</p>

<p>Internally displaced persons (IDPs) are people or groups of individuals who have been forced to leave their homes or places of habitual residence, in particular as a result of, or in order to avoid the effects of armed conflict, situations of generalised violence, violations of human rights, or natural or man-made disasters, and who have not crossed an international border. For the purposes of UNHCR's statistics, this population only includes conflict-generated IDPs to whom the Office extends protection and/or assistance. Since 2007, the IDP population also includes people in an IDP-like situation. For global IDP estimates, see www.internal-displacement.org.</p>

<p>Returned refugees are former refugees who have returned to their country of origin spontaneously or in an organised fashion but are yet to be fully integrated. Such return would normally only take place in conditions of safety and dignity.</p>

<p>Returned IDPs refer to those IDPs who were beneficiaries of UNHCR's protection and assistance activities and who returned to their areas of origin or habitual residence during the year.</p>

<p>Stateless persons are defined under international law as persons who are not considered as nationals by any State under the operation of its law. In other words, they do not possess the nationality of any State. UNHCR statistics refer to persons who fall under the agency’s statelessness mandate because they are stateless according to this international definition, but data from some countries may also include persons with undetermined nationality.</p>

<p>Others of concern refers to individuals who do not necessarily fall directly into any of the groups above, but to whom UNHCR extends its protection and/or assistance services, based on humanitarian or other special grounds.</p>
        <p style="font-weight: 700;">Source: http://popstats.unhcr.org/en/overview</p>
      </div>

</body>
</html>
