<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="http://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/topojson.v1.min.js"></script>
  <style>

.circle{
  fill: rgb(247, 148, 32);
  stroke: black;
  stroke-width: 0.7;
  opacity: 0.7;
}
.land {
  fill: #ddd;
}

#cells.voronoi path.cell {
  stroke: brown;
}

.country_borders {
  fill: none;  
  stroke: rgba(13, 46, 80, 0.7);
}

.voronoi {
  fill: none;
  stroke: #000;
  stroke-opacity: 0.1;
  pointer-events: all;
}

path.arc {
  pointer-events: none;
  fill: none;
  stroke: #000;
  display: none;
}
body {
    background: rgba(13, 46, 80, 0.7) /* Green background with 30% opacity */
}
.airport-arc {
  fill: black;
}
.airport:hover .airport-arc {
  stroke: rgba(247, 148, 32, 0.7);
  fill: none;
  stroke-width: 1.5px;
}

.airport-cell {
  fill: none;
  stroke: #000;
  stroke-opacity: 0.1;
  pointer-events: all;
}

.airport:hover .airport-link{
  stroke: #f00;
}
}
</style>
</head>
<body>  
<script type="text/javascript">
//  stroke: #f00;
var margin = 75,
    width = 1400 - margin,
    height = 600 - margin;

var svg = d3.select("body")
          .append("svg")
          .attr("width", width + margin)
          .attr("height", height + margin)
          .append('g')
          .attr('class', 'map');


var projection = d3.geoMercator()
                   .scale(170)
                   .translate([width / 2, height / 1.2]);

var path = d3.geoPath()
             .projection(projection)
             .pointRadius(2.5);
var voronoi = d3.voronoi()
    .extent([[-1, -1], [width + 1, height + 1]]);
/*
var voronoilocal = d3.voronoi()
                      .x(function(d) { return d[0]; })
                      .y(function(d) { return d[1] })
                      .extent([[-1, -1], [width + 1, height + 1]]);
*/

var linksByOrigin = {},
      countCountry = {}, //Total de ocorrencias de cada cidade
      locationCountry = {}, //posicao em px de cada pa√≠s
      //positions = [], //posicao em px de cada long e lat
      countryF = [];

var opacityScale = d3.scaleLinear()
      .range([ 1,0.9,0.4,0.1,0.1])
      .domain([0,3,  4,  6,  10])
      .clamp(true);


var colorScale = d3.scaleLinear()
      .range(['#fff7b9','#fff196','#ffea72','#ffe348','#fddc18'])
      .domain([0,1,2,4,6])
      .clamp(true);

d3.queue()
    .defer(d3.json, "geo.json")
    .defer(d3.csv, "unhcr_2016.csv", altData)
    .defer(d3.csv, "country.csv", formatCountry)
    .await(ready);

function ready(error, worldmap, countries, countryGeo) {
  if (error) throw error;

///////////Cria mapa////////////////////////////////////////////////////////
  svg.append("path")
      .datum(topojson.feature(worldmap, worldmap.objects.land))
      .attr("class", "land")
      .attr("d", path);

  svg.append("path")
      .datum(topojson.mesh(worldmap, worldmap.objects.countries, function(a, b) { return a !== b; }))
      .attr("class", "country_borders")
      .attr("d", path);


//////////////Agrupa dados////////////////////////////////////////////////////
  var nested = d3.nest()
                 .key(function(d) {
                  return d['Destination'];
                  })
                 .key(function(d) {
                    return d['Origin'];
                 })                 
                 .rollup(agg_year)
                 .entries(countries);


  
 
  ////////////////Formatar os dados//////////////////////////
/*
  countries.forEach(function(d) {
    var origin = d.Origin,
        destination = d.Destination;
    locationCountry[origin] = [+d.long_origin, +d.lat_origin];
    locationCountry[destination] = [+d.long_dest, +d.lat_dest];
    countCountry[origin] = (countCountry[origin] || 0) + 1;
    countCountry[destination] = (countCountry[destination] || 0) + 1;    
  });
*/
  var positions = [];
  var countryid = d3.map(countryGeo, function(d) { return d.country});
  var linkedCoords = [];
  var ttPop = 0;
  nested.forEach(function(k){ 
    linkedCoords = []
    k.arcs = {type: "MultiLineString", coordinates: []};
    var target = countryid.get(k.key);
    k[0] = +target[0];
    k[1] = +target[1];
    positions.push(projection([+target[0],+target[1]]));
    k.values.forEach(function(v) {
      var source = countryid.get(v.value.origin)
      if ((isLatitude(source[1])) && (isLongitude(source[0]))){
        if ((isLatitude(target[1])) && (isLongitude(target[0]))){                  
          linkedCoords.push([source, target]);
          linkedCoords.push([target, source]);
          ttPop += v.value.total_population;
    }//a.values.forEach(function(b) {
    
      };//if ((isLatitude(source[1])) && (isLongitude(source[0]))){      
    });
    linkedCoords.forEach(function(link){
      k.arcs.coordinates.push(link)
    });
    k.total_population = ttPop;
    delete k.values;
    countryF.push(k);
  });

  delete countryF.values;

  var population_max = d3.max(countryF, function(d) {
                return d.total_population;
            });

  var radius = d3.scaleSqrt()
                 .domain([0, population_max])
                 .range([0, 15]);

////////////////////////////// Desenha Circulos ///////////////////////////////
/*
  svg.append('g')
    .attr("class", "circle")
    .selectAll('circle')
    .data(nested)
    .enter()
    .append('circle')
    .attr('cx', function(d) {return d.value['x'];})
    .attr('cy', function(d) {return d.value['y'];})
    .attr('r', function (d){ return radius(d.value['population']); });
*/
  
 ////////////////////////////// Prepara dados e ///////////////////////////////
 ////////////////////////////// Cria vinculos entre eles//////////////////////
  
 // let unique_positions = [...new Set(positions)]; 
 // positions = positions.filter(Boolean);

  //countries = countries.filter(Boolean);
  countryF = countryF.filter(function(d) { return d.arcs.coordinates.length; });
 
  svg.append("path")
      .datum({type: "MultiPoint", coordinates: countryF})
      .attr("class", "airport-dots")
      .attr("d", path);


  svg.append('g')
    .attr("class", "circle")
    .selectAll('circle')
    .data(countryF)
    .enter()
    .append('circle')
    .attr('cx', function(d) {
              var x = projection([d[0],d[1]])
      return x[0];})
    .attr('cy', function(d) {
      var x = projection([d[0],d[1]]) 
      return x[1];})
    .attr('r', function (d){ return radius(d.total_population); });

  // Calcula o voronoi para as posicoes
 // var polygons = voronoilocal.polygons(positions);
  var polygons = voronoi.polygons(countryF.map(projection));

  var airport = svg.selectAll(".airport")
                   .data(countryF)
                   .enter()
                   .append("g")
                   .attr("class", "airport");
  

  airport.append("path")
      .attr("class", "airport-arc")
      .attr("d", function(d) { return path(d.arcs); })
      .style("opacity", function(d) { return opacityScale(d.Total_Population)*0.1; });

  airport.append("path")
      .data(polygons)
      .attr("class", "voronoi")
      .attr("d", function(d) { return d ? "M" + d.join("L") + "Z" : null; })
      .style("opacity", function(d) { return opacityScale(d.Total_Population)*0.1; });

 ///////////////////////////////////////////////////////////////////////////

}//function ready(error, worldmap, countries) {


function altData(d) {
    d.Year        = +d.Year;
    d.arcs = {type: "MultiLineString", coordinates: []};
    return d;   
}//altData

function formatCountry(d) {
    d[0] = +d.longitude;
    d[1] = +d.latitude;
    d.arcs = {type: "MultiLineString", coordinates: []};
    return d;   
}//formatCountry

//code from: https://stackoverflow.com/questions/39842004/why-use-regular-expressions-to-validate-latitude-and-longitude-in-javascript
function isLatitude(lat) {
  return isFinite(lat) && Math.abs(lat) <= 90;
}

function isLongitude(lng) {
  return isFinite(lng) && Math.abs(lng) <= 180;
}

function agg_year(leaves) {
    var total = d3.sum(leaves, function(d) {
          return d['Total_Population'];
      });
    
    var origin = leaves[0]['Origin'];
    var destination = leaves[0]['Destination'];

    return {
      'destination' : destination,      
      'origin' : origin,
      'total_population' : total,
      'arcs': {type: "MultiLineString", coordinates: []}
    };
  }//agg_year(l

</script>
</body>
</html>
